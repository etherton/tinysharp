// the file is parsed in two passes.
// the first pass processes all the global names (attributes,
// properties, objects, actions) and also extracts any dictionary
// words that appear in any property, action definition, or routine.

// token parsing: skip all whitespace. if quote, collect until closing quote.
// backslash inside string escapes next character. if numeric, collect while numeric.
// if alpha, collect while alphanumeric.  if one of "(,);:" always a single token. 
// if any other visible character, collect while visible character. 
// # is considered alpha at start of string

// basic syntax is
// stmt: 
//   directive;
//   if (branch_test) stmt else stmt
//   while (branch_test) stmt
//   repeat stmt while (branch_test);
//   return expr;
//   dest = expr;
//   rtrue;
//   rfalse;
//   { stmts }
// stmts:
//   stmts stmt
//   stmt
// branch_test:
//   unary_branch(expr)
//   unary_branch(expr)->dest
//   binary_branch(expr)
//   binary_branch(expr)->dest
// dest:
//   global_name
//   local_name
// integer_literal:
//   digit+
//   'dictionary_word'
//   #attribute
//   routine_name
// expr:
//   dest
//   integer_literal
//   unary_op expr
//   expr binary_op expr
//   expr == integer_literal,integer_literal[,integer_literal][,integer_literal]

// If there are two attributes, they are opposites
// Each resolves to an index between 0-31 (0-47 on v4+)
// it's not always strictly necessary but reduces the chance of programming errors
attribute global lit;
attribute global general;
attribute global supporter;
attribute object clothing;
attribute object worn;
attribute object scenery;

// a'name means name should be an attribute index (ao'name for object, al'name for loc)
// p'name means name should be a property index (po'name for object, pl'name for loc)
// o'name means name should be an object index
// l'name means name should be a location index
// r'name means name should be a routine address
// s'name means name should be a string addres
// c'name means name should be a command index

// branch opcodes can only appear inside an if/while/repeat statement.

// trace and trace_obj take a bit mask and either a string or object number
// they are only kept in debug builds. they test the bit mask against a global
// trace enable which can be set by other debug commands.

// the global constant $object_count is always the count
// of objects in the game. for properties that can refer
// to an object, string, or routine, values less than or
// equal to $object_count are an object. otherwise it's
// a routine. a string constant where a routine is allowed
// generates a dummy routine that calls print_ret and the string.
// (this costs two bytes, one for the local count and one
// for the print_ret opcode)

// words can refer to up to four dictionary words. a word is
// a nonzero index into a sorted list of vocabulary words
// if more than four words are needed, the property is
// stored as three bytes; the first byte is the number of
// words and the next two bytes contain the address of
// that many word indices.

constant false = 0;
constant zero = 0; 
constant true = 1;
constant adjBit = 1 << 7;
constant nounBit = 1 << 6;

// plain properties can be attached to rooms or objects
// object properties can only be attached to objects
// room properties can only be attached to rooms
// object and room properties cannot be given nonzero default values
// because they actually overlap
property global description;
property global before;
property global after;
property object adjective gains adjBit;
property object noun gains nounBit;
property location dummy;
property location n_to;
property location s_to;
property location e_to;
property location w_to;

// marks these words as equivalent for all purposes.
/*
synonym 'north' 'n' 'northern';
synonym 'south' 's' 'southern';
synonym	'east' 'e' 'eastern';
synonym 'west' 'w' 'western';
synonym 'get 'take';
synonym 'examine' 'x';
synonym 'again' 'g';
synonym 'wait' 'z';
*/

// the direction directive takes a nonzero property value followed by one or more words.
direction n_to 'north' 'n';
direction s_to 'south' 's';
direction e_to 'east' 'e';
direction w_to 'west' 'w';

// the first three must be in this order for status line (v3) games.
global room;
global score;
global turns;
global scratch;		// fourth global is used as a dummy storage slot for branches and subroutine calls that ignore result.
global deadflag;

// player is always first at object 1. this also guarantees that
// a room a player can be in is always greater than 1, meaning routines
// that return a location can also rtrue or rfalse as well.
object player "Player" (foyer) {
}

// If a string constant crosses multiple lines, any number of spaces and tabs
// followed by a line break is consumed. Next, N line breaks is turned into
// N-1 line breaks (usually zero) and then finally, one or more spaces and/or
// tabs (if present) becomes a single space. This is a very complicated way
// of saying you can break up a long string and it will end up looking reasonable.
// if you need to break up a line in the middle of a word, just start the remainder
// of the word at the leftmost column of the next line.
location foyer "Foyer of the Opera House" { 
	description: 
		"You are standing in a spacious hall, splendidly decorated in red
		and gold, with glittering chandeliers overhead. The entrance from
		the street is to the north, and there are doorways south and west.";
	s_to: bar;
	n_to: "You've only just arrived, and besides, the weather outside seems
	    to be getting worse.";
	w_to: cloakroom;
	lit;
}

// location_or_object new_name "short description" ['(' parent ')'] '{'
// [property_or_attribute...] '}'
// property: property_name ':' value ';'
// attribute:
//	attribute_name ';'
// value: 
//   global_symbol
//   [dictionary_word]+
//   routine_defintion
// routine_definition: '[' [params..] [';' locals..] ']' '{' stmts '}'
location cloakroom "Cloakroom" {
	description: "The walls of this small room were clearly once lined with hooks,
	 	though now only one remains. The exit is a door to the east.";
	e_to: foyer;
	lit;
}

object hook "small brass hook" (cloakroom) {
	adjective: 'small' 'brass';
	noun: 'hook' 'peg';
	description: [;c] {
		print "It's just a small brass hook, ";
		if (self has child -> c) {
			print "with a ";
			print_obj c;
			print_ret " hanging on it.";
		}
		else
			print_ret "screwed to the wall.";
	}
	scenery; supporter;
}

object hat "a nondescript hat" (foyer) {
	noun: 'hat';
	description: "It's a really boring hat just meant to test the cloakroom";
	clothing;
}

global message_damage;

location bar "Foyer Bar" {
	description: "The bar, much rougher than you'd have guessed after the opulence
			of the foyer to the north, is completely empty. There seems to
			be some sort of message scrawled in the sawdust on the floor.";
	n_to: foyer;
	before: [act do; temp] {
		if (act in {#look,#inv})
			rtrue;
		else if (act is #leave and self hasnt lit and do isnt foyer) {
			++message_damage;
			++message_damage;
			print_ret "Blundering around in the dark isn't a good idea!";
		}
		else if (self hasnt lit) {
			++message_damage;
			print_ret "In the dark? You could easily disturb something!";
		}
		else
			rtrue;
	}
}

object cloak "velvet cloak" (player) {
	adjective: 'handsome' 'velvet' 'black' 'satin';
	noun: 'cloak';
	description: "A handsome cloak, of velvet trimmed with satin, and slightly
			spattered with raindrops. Its blackness is so deep that it
			almost seems to suck light from the room.";
	before: [act] {
		if (act in {#drop,#puton} and room isnt cloakroom)
			print_ret "This isn't the best place to leave
				a smart cloak lying around.";
		rfalse; // not handled, allow action to continue
	}
	after: [act] {
		if (act is #take)
			bar loses lit;
		else if (act in {#puton,#drop} and room is cloakroom) {
			bar gains lit;
			if (act is #puton and self has general) {
				self loses general;
				++score;
			}
		}
		rfalse;
	}
	clothing; general; worn;
}

object message "scrawled message" (bar) {
	adjective: 'scrawled';
	noun: 'message' 'sawdust' 'floor';
	description: []{
		if (message_damage < 2) {
			++score;
			deadflag = 2;
			print_ret "The message, neatly marked in the sawdust, reads...";
		}
		else {
			deadflag = 3;
			print_ret "The message has been carelessly trampled, making it
			  difficult to read. You can just distinguish the words...";
		}
	}
}

// there are several ways to declare dictionary words. the syntax always
// uses single quotes. the context determines which bits are set on the word
// to identify default parts of speech
// dir_bit, adj_bit, noun_bit, verb_bit
// directions are also adjectives in most cases


routine perform [act obj iobj] {
	act = act;
	rfalse;
}

// articles are skipped entirely except they do force the
// parser to expect a direct or indirect object.
article 'a' 'an' 'the';

// words in action syntax get encoded into nonzero indices
// we support up to 8191 unique words (plenty since each
// takes at least four bytes and must be below 64k mark)
// the upper three bits indicate the type of entry:
// 1--: this is the last entry in the table. routines follow.
// -00: this is an object placeholder; lower bits indciate which kind
// -01: this is a single word
// -10: this is the second word of a two-word phrase

// when a 'word' appears in a routine, it evaluates to the 0-based index
// of the word in the master dictionary

// a placeholder encodes a bit shift between 0 and 12; there can be
// up to 13 of them.
placeholder held;		// object in your possession
placeholder here;		// object in your room (parent)
placeholder anyobj;		// any object not in room zero
placeholder compass;	// a compass direction

routine Inventory [;i] {
	if (player has child -> i) {
		print "You are carrying:";
		crlf;
		repeat {
			print "  ";
			print_obj i;
			crlf;
		} while (i has sibling -> i);
		rtrue;
	}
	else
		print_ret "You are empty-handed.";
}

routine BlockBefore [act obj;r] {
	if (obj is zero)
		rfalse;
	r = obj.before;
	if (r isnt zero)
		return call r(act,obj);
	else
		rfalse;
}

routine CheckBefore [act obj;r] {
	if (obj isnt zero) {
		r = obj.before;
		if (r isnt zero)
			return call r(act,obj);
	}
	rtrue;
}

routine CheckAfter [act obj;r] {
	if (obj isnt zero) {
		r = obj.after;
		if (r isnt zero)
			return call r(act,obj);
	}
	rtrue;
}

routine CallAfter [act obj;r] {
	if (obj isnt zero) {
		r = obj.after;
		if (r isnt zero)
			return call r(act,obj);	
	}
	rtrue;
}

routine Travel [dir;r] {
	if (CheckBefore(#leave,room) is true) {
		print "room = "; print_num room; crlf;
		print "dir = "; print_num dir; crlf;
		r = room.dir;
		print "now r = "; print_num r; crlf;
		if (r is zero)
			print_ret "You can't go in that direction";
		else if (r > $object_count)
			r = call r();
		// player is the first object, and cannot be a room.
		// this leave rfalse and rtrue as valid responses.
		if (r > 1) {
			move player into r;
			room = r;
			CallAfter(#enter,r);
		}
	}
	rfalse;
}

routine Take [obj] {
	if (obj hasnt scenery) {
		if (BlockBefore(#take,room) is true or BlockBefore(#take,obj) is true)
			rtrue;
		move obj into player;
		CallAfter(#take,obj);
		rfalse;
	}
	else
		print_ret "You can't take that, it's just scenery.";
}

routine Examine [obj; desc] {
	desc = obj.description;
	if (desc isnt zero)
		call desc();
	else {
		print "It's just an ordinary ";
		print_obj obj;
	}
	rtrue;
}

routine Drop [obj] {
	if (player holds obj and CheckBefore(#drop,room) isnt false and
		CheckBefore(#drop,obj) isnt false) {
		move obj into player parent;
		rtrue;
	}
	else
		rfalse;
}

// each dictionary word has an extra byte associated with it
// vanpdddd
// v: word can be a verb (appears first in an action statement)
// a: word can be an adjective (appears in an adjective list of at least one object)
// n: word can be a noun (appears in the noun list of at least one object)
// p: word can be a preposition (appears between direct and indirect object)
// dddd: if nonzero, word refers to a direction property index
// if dddd is 15, word is an article (and is therefore ignored except that
// it starts the beginning of a placeholder)

// each dictionary word has an extra two bytes associated with it
// adj_bit - set if word is an adjective (appears in adjective list of an object)
// noun_bit - set if word is a noun (appears in noun list of an object) (payload is first matching object)
// verb_bit - set if word is a verb (payload is action index)
// if payload is nonzero, the word is a synonym
// if payload is nonzero but larger than number of words, it's a biased direction proeprty index

// actions are scanned in-order
// so specific cases need to be before more general cases
// some actions are really just messages and aren't part of grammar
action #inv { 'i'/'inventory'/'take inventory': Inventory }
action #take { 'get'/'take'/'pick up' here: Take }
action #drop { 'drop'/'put down' held: Drop }
action #look { 'look at'/'examine'/'x' here/held: Examine }
action #puton { 'hang'/'place'/'put' held 'on'/'upon' here: [do ido] {
	if (ido has supporter) {
		if (ido has child)
			print_ret "There's no room.";
		else if (CheckBefore(#puton,room) isnt false and 
				CheckBefore(#puton,do) isnt false and 
				CheckBefore(#puton,ido) isnt false) {
			move do into ido;
			CallAfter(#puton,ido);
			CallAfter(#puton,do);
			CallAfter(#puton,room);
			rfalse;
		}
		else
			rtrue;
	}
	else
		print_ret "You can't put it on that.";
}}
action #go { 'go'/'walk'/'travel' compass: Travel }
action #leave;
action #enter;

global text_buffer = byte_array(64) { 63 };
global parse_buffer = byte_array(64) { 15 };

routine DoTurn[;wc wp wt] {
	text_buffer[0] = 63;
	parse_buffer[0] = 15;
	// storeb(text_buffer,0,63);
	// storeb(parse_buffer,0,15);
	// text_buffer[0] is the size of the input buffer
	// parse_buffer[0] is the max number of words
	// parse_buffer[1] is the actual number of words parsed
	// each word consists of four bytes:
	// first two bytes is address of the word, or 0 if unknown
	// next byte is the length of the word, then the position in text_buffer.
	repeat {
		sread(text_buffer, parse_buffer);
		wc = parse_buffer[1];
	} while (wc is zero);
	wp = parse_buffer + 2;
	print "wp = "; print_num wp; crlf;
	wt = wp[[0]];
	print "word addr = "; print_num wt; crlf;
	wt = wt[$dict_entry_size];
	if ((wt & 15) isnt zero) {
		print "wt is "; print_num wt & 15; crlf;
		return Travel(wt & 15);
	}
	rfalse;
}

routine Startup[] {
   room = player parent;
   print_ret "^Hurrying through the rainswept November night, you're glad to see the
	bright lights of the Opera House. It's surprising that there aren't more
	people about but, hey, what do you expect in a cheap demo game...?^";
}

routine main [] {
	Startup();
	while (deadflag is zero) {
		DoTurn();
		if (deadflag is 3)
			print "*** You have lost! ***";
		else if (deadflag is 2)
			print "*** You have won! ***";
		if (deadflag isnt zero) {
			crlf;
			print "Restart or quit?";
			restart;
		}
	}
	quit;
}
